package thinice.parser;

//---------------------------Imported Libraries---------------------------------

import java_cup.runtime.*;
import thinice.util.*;
import thinice.lexer.*;
import thinice.AST.*;
import thinice.TS.*;

//---------------------------Code Definition------------------------------------

action code {: 

	boolean declaracion;

	int getLinea() {
		return ((ThinIceLexer)parser.getScanner()).getLinea();
	}

	int getColumna(){
		return ((ThinIceLexer)parser.getScanner()).getColumna();
	}

	/*
	SimboloAbstracto getNombreArchivo() {
		return ((ThinIceLexer)parser.getScanner()).getNombreArchivo();
	}
	*/
:}

//---------------------------Terminal Definition--------------------------------

terminal PROGRAM;
terminal PAR_I, PAR_D, LLA_I, LLA_D, COR_I, COR_D, PUNT_C, COMA;
terminal INT, BOOLEAN;
terminal IF, ELSE, DO, WHILE, FOR;
terminal ASIG;
terminal SUMA, RESTA, MULTI, DIV, MOD;
terminal AND, OR, NOT;
terminal MENOR, MENOR_IGUAL, MAYOR, MAYOR_IGUAL, IGUAL, DIFERENTE;
terminal BOOLEANO, ENTERO;
terminal ID;
terminal EMPTY, ERROR;

//---------------------------No Terminal Definition-----------------------------

nonterminal programa;
nonterminal lista_sent;
//--------------------------------------------------
nonterminal sent;
nonterminal sent_decl;
nonterminal tipo_var;
nonterminal sent_asig;
nonterminal func_call;
nonterminal lista_parm;
nonterminal sent_if;
nonterminal else;
nonterminal sent_do;
nonterminal sent_for;
//--------------------------------------------------
nonterminal exp;
nonterminal exp_booleana;
nonterminal op_comparacion;
nonterminal exp_aritmetica;
nonterminal op_aritmetica;
nonterminal exp_factor;
nonterminal op_factor;
nonterminal termino;
//--------------------------------------------------
nonterminal literal;
nonterminal variable;
nonterminal vector;

//---------------------------Precedence Definition------------------------------

precedence left PAR_I, PAR_D;
precedence left LLA_I, LLA_D;
precedence left COR_I, COR_D;
precedence left SUMA, RESTA;
precedence left MULTI, DIV, MOD;

//---------------------------Grammar Definition---------------------------------

programa ::=		PROGRAM:p PAR_I PAR_D LLA_I lista_sent:ls LLA_D
				{:
					RESULT = new Programa(ls, p.getLinea(), p.getColumna());
				:};


lista_sent ::=		lista_sent:ls sent:s
				{:
					RESULT.agregarElemento(s);
				:}
				|	sent:s
				{:
					RESULT = new ListaSentencia(s.getLinea(), s.getColumna);
					RESULT.agregarElemento(s);
					
				:};


sent ::=			sent_decl:sd PUNT_C
				{:
					RESULT = sd;
				:}
				|	sent_asig:sa PUNT_C
				{:
					RESULT = sa;
				:}
				|	func_call:fc PUNT_C
				{:
					RESULT = fc;
				:}
				|	sent_if:si
				{:
					RESULT = si;
				:}
				|	sent_do:sdw
				{:
					RESULT = sdw;
				:}
				|	sent_for:sf
				{:
					RESULT = sf;
				:}
				|	ERROR:er
				{:
					RESULT = new Error(er, er.getLinea(), er.getColumna());
				:};


sent_decl ::=		tipo_var:tv variable:v
				{:
					RESULT = new DeclSimple(tv, v, getLinea(), getColumna());
				:}
				|	tipo_var:tv sent_asig:sa
				{:
					RESULT = new DeclCompleja(tv, sa, getLinea(), getColumna());
				:};
tipo_var ::=		INT:i
				{:
					RESULT = new TipoEntero(i);
				:}
				|	BOOLEAN:b
				{:
					RESULT = new TipoBool(b);
				:};


sent_asig ::=		variable:v ASIG:a exp:e
				{:
					RESULT = new Asignacion(v, e, a.getLinea(), a.getColumna());
				:};


func_call ::=		ID:id PAR_I:f lista_parm:lp PAR_D
				{:
					RESULT = new LlamadaFuncion(id, lp, id.getLinea(), id.getColumna());
				:};
lista_parm ::=		lista_parm:lp COMA exp:e
				{:
					RESULT.agregarElemento(e);
				:}
				|	exp:e
				{:
					RESULT = new ListaParametros();
					RESULT.agregarElemento(e);
				:};


sent_if ::=			IF PAR_I exp:e PAR_D LLA_I lista_sent:ls LLA_D else:el
				{:
				:};
else ::=			ELSE LLA_I lista_sent:ls LLA_D
				{:
				:}
				|	EMPTY
				{:
				:};


sent_do ::=			DO lista_sent:ls WHILE PAR_I exp:e PAR_D
				{:
				:};


sent_for ::=		FOR PAR_I sent_asig:sai PUNT_C sent_asig:sap PUNT_C exp:e PAR_D LLA_I lista_sent:ls LLA_D
				{:
				:};


exp ::= 			exp_booleana:ebi AND exp_booleana:ebo
				{:
				:}
				|	exp_booleana:ebi OR exp_booleana:ebo
				{:
				:}
				|	NOT exp:e
				{:
				:}
				|	exp_booleana:ebo
				{:
				:};


exp_booleana ::=	exp_booleana:ebo op_comparacion:oc exp_aritmetica:ear
				{:
				:}
				|	exp_aritmetica:ear
				{:
				:};
op_comparacion ::=	MENOR
				{:
				:}
				|	MENOR_IGUAL
				{:
				:}
				|	MAYOR_IGUAL
				{:
				:}
				|	MAYOR
				{:
				:}
				|	IGUAL
				{:
				:}
				|	DIFERENTE
				{:
				:};


exp_aritmetica ::=	exp_aritmetica:ear op_aritmetica:oa exp_factor:efa
				{:
				:}
				|	exp_factor:efa
				{:
				:};
op_aritmetica ::=	SUMA
				{:
				:}
				|	RESTA
				{:
				:};


exp_factor ::=		exp_factor:efa op_factor:of termino:t
				{:
				:}
				|	termino:t
				{:
				:};
op_factor ::=		MULTI
				{:
				:}
				|	DIV
				{:
				:}
				|	MOD
				{:
				:};


termino ::=			PAR_I exp:e PAR_D
				{:
				:}
				|	func_call:fc
				{:
				:}
				|	literal:li
				{:
				:}
				|	variable:v
				{:
				:};


literal ::=			ENTERO
				{:
				:}
				|	BOOLEANO
				{:
				:};


variable ::=		ID
				{:
				:}
				|	vector:vec
				{:
				:};


vector ::=			ID COR_I exp:e COR_D
				{:
					if(declaracion){
						declaracion = false;
					}
					else{

					}
				:};